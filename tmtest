#!/usr/bin/perl -w

# tmtest
# Scott Bronson
# 14 Sept 2000

# Copyright (C) 2000-2004 Scott Bronson, bronson@rinspin.com
# This file is covered by the GNU GPL v2.

# Please don't look at this code.  It's needed a rewrite for
# a good three years now...


use strict; 
use Config;
use Getopt::Long ();
use File::Spec ();
use File::Basename ();
use File::Temp ();
require 'shellwords.pl';

use vars qw( $VERSION );
$VERSION = "0.88";

my $diff = "/usr/bin/diff";		# full path to the diff program
my $mv = "/bin/mv";				# the mv executable (used when exploding)
my $vi = "/usr/bin/vi";			# only if the EDITOR env var isn't set
my $file_re = "\\.te?st\$";		# to be run, a test filename must match.

$| = 1;		# don't buffer stdout

$SIG{__DIE__} = sub {
	# die normally produces an exit code that matches the current errno.
	# this is a problem because different platforms have different errnos.
	# if a test could not be run, we always return an exit code of 255.
	$! = 255;
	die @_;
};

# global variables

my $test_runs = 0;
my $test_successes = 0;
my $test_failures = 0;
my $test_dumpstats = 0;
my $explicit_config = undef;	# the test file if -f is specified

my %configs;

my $exit_value_hack = 0;		# todo: remove me


my $usage = <<EOL;
usage: tmtest [opts] [test files or dirs...]
       -o: dump actual results rather than just go/nogo
       -d: diff actual results against expected results
       -cNUM: extract the given command
       -hNUM: extract the given here document
       -e: extract all cmds and heredocs
       -v: print copious debug information
EOL

my $dump_results = 0;
my $explode_file = 0;
my $diff_results = 0;
my $syntax_check = 0;		# deprecated?
my $extract_here = undef;	# deprecated?
my $extract_cmd = undef;	# deprecated?
my $custom_file = undef;
my $debug = 0;
my $editor = 0;

# Need to know if signal raised on child is sigint.
my %signum;
my @signame;
get_signals();

Getopt::Long::Configure ("bundling");
exit(1) unless Getopt::Long::GetOptions(
	"dump|o"		=> \$dump_results,
	"explode|e"		=> \$explode_file,
	"diff|d"		=> \$diff_results,
	"syntax|Z"		=> \$syntax_check,	# deprecated?
	"heredoc=s"		=> \$extract_here,	# deprecated?
	"cmd=s"			=> \$extract_cmd,	# deprecated?
	"configfile|f=s" => \$custom_file,
	"verbose+"		=> \$debug,			# needs to change
	"edit|v"		=> \$editor,
	"help|h|?"		=> sub { print "$usage\n"; exit(0); },
	"version|V"		=> sub { print "tmtest version $VERSION\n"; exit(0); },
	);


my $quiet = 0;
if($diff_results || $explode_file) {
	$quiet = 1;
}

if(defined($extract_here) and $extract_here !~ /^\d+$/) {
	die "-h requires a positive integer, not '$extract_here'!\n";
}
if(defined($extract_cmd) and $extract_cmd !~ /^\d+$/) {
	die "-c requires a positive integer, not '$extract_cmd'!\n";
}

if(defined $custom_file) {
	# read the explicit configuration file
	my($file, $dir) = File::Basename::fileparse($custom_file);
	$explicit_config = read_test_file($custom_file, File::Spec->rel2abs($dir), 0);
}

if($editor) {
	my $editor = $ENV{EDITOR} || $vi;
	exec($editor, @ARGV);
}

if( @ARGV == 1 && $ARGV[0] eq "-" ) {
	# One last argument is a dash?  Read from stdin.
	my @file = <STDIN>;
	my $test = read_test(\@file, "STDIN", File::Spec->rel2abs(File::Spec->curdir()), 1);
	process_test( $test );
} elsif(@ARGV) {
	for(@ARGV) {
		if( -f $_ ) {
			if(/$file_re/o) {
				# process a single test file
				my($file, $dir) = File::Basename::fileparse($_);
				my $cwd = File::Spec->rel2abs(File::Spec->curdir());
				chdir $dir;
				process_test(read_test_file($file, File::Spec->rel2abs(File::Spec->curdir()), 1));
				chdir $cwd;
			} else {
				print("skip $_ (filename doesn't end in .test).\n");
			}
		} elsif(-d $_) {
			# search this dir and all subdirs for tests
			search_test_dirs($_);
		} else {
			print STDERR "File $_ not found.\n";
		}
	}
} else {
	# If user didn't supply any tests to run,
	# run everything in current dir.
	search_test_dirs(".");
}

if($test_dumpstats && !$quiet) {
	print "\n$test_runs test" .
		($test_runs != 1 ? "s" : "") . " run, $test_successes success" .
		($test_successes != 1 ? "es" : "") . ", $test_failures failure" .
		($test_failures != 1 ? "s" : "") . "\n";
}

exit 0;


# Dunno why this isn't in the stdlibs yet!

sub get_signals
{
	defined $Config{sig_name} or die "No signals on this system??\n";
	my $i = 0;
	foreach my $name (split(' ', $Config{sig_name})) {
		$signum{$name} = $i;
		$signame[$i] = $name;
		$i++;
	}
}


# or this!

sub slurp_file
{
	my $file = shift;

	my(@data, $data);

	open FH, $file or die "can't open $file: $!\n";
	if(wantarray) {
		@data = <FH>;
	} else {
		local $/;
		$data = <FH>;
	}

	close FH or die "cannot close $file: $!";

	return wantarray ? @data : $data;
}


# Converts all newlines in the input string to the given $chr, space by default.

sub trimnl
{
	my $str = shift;
	my $chr = shift;
	$chr = ' ' unless defined $chr;

	$str =~ s/\n$//;		# trailing newline is just deleted
	$str =~ s/\n/$chr/g;	# but all others are converted into $chr
	return $str;
}


# For enabling and disabling, we support i.e. "disabled: yes, because you smell."
# This just grabs the important fragment "yes" or "no" up front.

sub grab_frag
{
	local $_ = shift;
	/^\s*([A-Za-z0-9]*)/;
	return $1;
}


sub is_affirmative
{
	my $word = lc grab_frag(shift);

	for(qw(y yes 1 t true on)) {
		return 1 if $word eq $_;
	}

	return 0;
}


sub is_negative
{
	my $word = lc grab_frag(shift);

	for(qw(n no 0 f false off)) {
		return 1 if $word eq $_;
	}

	return 0;
}


# Checks the test data structure to see if the user has specified
# a minimum version required to run.  If not, it assumes that the
# current version is the minimum version required.

sub get_required_version
{
	my $test = shift;

	for (qw(require require-tmtest require-version version-required version)) {
		if(exists $test->{header}->{$_}) {
			return trimnl($test->{header}->{$_}->{value}, '');
		}
	}

	return $VERSION;
}


# Returns true if the test is enabled, false if disabled.
# If unknown, returns enabled.

sub is_test_enabled
{
	my $test = shift;
	my $hdr = $test->{header};

	for(qw(disabled disable)) {
		exists $hdr->{$_} and
			return !is_affirmative($hdr->{$_}->{value});
	}

	for(qw(enabled enable)) {
		exists $hdr->{$_} and
			return !is_negative($hdr->{$_}->{value});
	}

	return 1;
}


# Returns all the configuration files for the given directory.
# Maintains a cache of config files so it doesn't have to reprocess
# them each time.  The last config file returned is the one passed
# by the -f option (if it exists).

sub get_configs
{
	my $startdir = shift;	# must be absolute

	my @dirs = File::Spec->splitdir($startdir);
	my $dir = File::Spec->rootdir();

	my @configs;

	while(@dirs) {
		$dir = File::Spec->catdir($dir, shift @dirs);
		unless(exists $configs{$dir}) {
			my $file = File::Spec->catdir($dir, "tmtest.conf");
			my $conf = undef;
			if(-e $file) {
				$conf = read_test_file($file, $dir, 0);
			}
			$configs{$dir} = $conf;
		}
		if(exists $configs{$dir} && defined $configs{$dir}) {
			push @configs, $configs{$dir};
		}
	}

	defined $explicit_config and push @configs, $explicit_config;
	return @configs;
}


# Recursively searches through directories for tests and runs them.
# tmtest used to use File::Find to perform the recursive directory
# search.  However, I now want it to print subdirs as they're 
# entered, and to go in alphabetical order, processing first
# files, then directories.  Therfore, my own dirsearch is needed.

sub search_test_dirs
{
	my $path = shift;
	my $base = shift || $path;

	print "\nProcessing $base/\n" unless $quiet;

	# Since we're doing something recursive,
	# we'll print the final count at the end.
	$test_dumpstats = 1;

	if( chdir $path ) {
		opendir( DIR, '.' ) or die "Can't open $path: $!\n";
		my @names = sort readdir( DIR );
		closedir( DIR );

		# first, process files
		for( @names ) {
			next if $_ =~ /^\./;
			-f && /$file_re/o && process_test(
				read_test_file($_, File::Spec->rel2abs(File::Spec->curdir()), 1));
		}

		# then, process directories
		for( @names ) {
			next unless $_;
			next if $_ =~ /^\./;
			next if $_ eq 'CVS';
			-d && search_test_dirs( $_, "$base/$_" );
		}

		chdir '..';
	} else {
		die "Can't cd to $_: $!\n";
	}
}


sub get_test_cs
{
	my $test = shift;
	my $num = shift;

	if($num < 1) {
		die "You must specify a command: 1 or greater.\n";
	}
	if($num > @{$test->{cmds}}) {
		die "You're accessing command $num, but there are only " . 
			@{$test->{cmds}} . " commands in the testfile!\n";
	}

	my $cs =  $test->{cmds}->[$num-1];
	die "Unknown error" unless $cs;
	return $cs;
}


sub explode_file
{
	my $test = shift;
	my $testfile = $test->{file};

	my $dir = "/tmp/tmtest";
	if(!-d $dir) {
		mkdir($dir, 0777) or die "Couldn't create dir $dir: $!";
	}

	my $ncmds = @{$test->{cmds}};

	printf("Exploding $ncmds cmd%s from %s...\n",
		0+@{$test->{cmds}} == 1 ? "" : "s", $testfile);

	# if the output directory already contains files, we'll move
	# them into a different directory to avoid confusion.
	opendir(DIR, $dir);
	my @files = grep { -f } map { "$dir/$_" } readdir(DIR);
	if(@files) {
		# find a new temporary directory
		my $i = 0;
		my $newdir = undef;
		do {
			$newdir = "$dir/~bak-$i";
			$i += 1;
			last if $i > 100;
		} while(!mkdir($newdir));
		die "Could not create $newdir: $!\n" unless defined $newdir;

		# and move the files
		system($mv, @files, $newdir);
		if($? == -1) {
			print "Warning: failed to execute $mv \"" .
				join("\" \"", @files) . "\" $newdir: $!\n";
		} elsif($?) {
			print "Warning: $mv exited with " . ($? >> 8) . "\n";
		}
		printf("Moved \"" . join("\" \"", @files) . "\" into $newdir\n");
	}
	closedir(DIR);

	my $runfile = "$dir/RUN";
	open(RUN, ">$runfile") or die "Couldn't open $runfile: $!\n";
	print RUN <<EOL;
#!/bin/sh
#
# This file causes each command from $testfile
# to be executed in turn.  Executing it should produce exactly
# the same results as running the test using tmtest.

EOL

	for(my $i=1; $i <= @{$test->{cmds}}; $i++) {
		my $istr = ('0' x (length($ncmds) - length($i))) . $i;
		my $filename = "$dir/cmd-$istr";
		my $herename = "$dir/here-$istr";
		my $cs = get_test_cs($test, $i);

		# if this command is actually a crfile, create the file
		if($cs->{crfile}) {
			my $name = create_crfile($cs, $test, $herename);
			printf("  created $name\n");
			$test->{header}->{lc $cs->{name}} = {value => $name};
			print RUN "# command $i created $name\n";
			next;
		}

		my $cmd = get_executable_command($test, $cs);
		my $here = get_heredoc($cs, should_interpolate($test->{header}, "stdin") ?
				$test->{header} : undef);

		# create the cmd file
		open(FD, ">$filename") or die "Couldn't open $filename: $!\n";
		print FD "#!/bin/sh\n#\n# Command $i from \"" . $test->{file} . "\"\n\n";
		print FD "$cmd";
		print FD " < $herename" if defined $here;
		print FD "\n\n";
		close(FD) or die "Couldn't close $filename: $!\n";
		chmod(0777, $filename) or die "Couldn't mark $filename executable: $!\n";
		printf("Wrote $filename");

		# create the heredoc
		if(defined $here) {
			open(FD, ">$herename") or die "Couldn't open $herename: $!\n";
			print FD $here;
			close(FD) or die "Couldn't close $filename: $!\n";
			printf(" and $herename");
		}

		print RUN "$filename\n";

		printf("\n");
	}

	close(RUN) or die "Couldn't close $runfile: $!\n";
	chmod(0777, $runfile) or die "Couldn't mark $runfile executable: $!\n";
}


# Cleans up the test results (applies the eachline header)

sub clean_results
{
	my $test = shift;
	my $results = shift;

	return unless exists $test->{header}->{eachline};
	my $each = $test->{header}->{eachline}->{value};

	for($results->{stdout}, $results->{stderr}) {
		my $s = $_;
		# this splits on newline but keeps the newline as a part of the preceding string
		my @a = split(/(?<=\n)/, $_);
		for(@a) {
			eval $each;
			die $@ if $@;
		}
		$_ = join('', @a);
		if($debug && $s ne $_) {
			print "Clean: old='$s' new='$_'\n";
		}
	}
}


# Given the test structure, performs the test.
# This might involve either printing the syntax check or extracting
# a here document rather than actually RUNNING the test...

sub process_test
{
	my $test = shift;

	if($syntax_check) {
		print_test($test);
	} elsif($explode_file) {
		explode_file($test);
		exit(0);
	} elsif($extract_cmd) {
		my $cs = get_test_cs($test, $extract_cmd);
		my $cmd = get_executable_command($test, $cs);
		print "$cmd\n";
		exit(0);
	} elsif($extract_here) {
		my $cs = get_test_cs($test, $extract_here);
		my $here = get_heredoc($cs);
		defined $here or die "Command $extract_here does not have a here doc!\n";
		if($cs->{crfile}) {
			if(	should_interpolate($test->{header}, $cs->{name}) ||
				should_interpolate($test->{header}, "files") ||
				($cs->{executable} && should_interpolate($test->{header}, "execfiles"))
			) {
				$here = interpolate_headers($test->{header}, $here);
			}
		} else {
			if(should_interpolate($test->{header}, "stdin")) {
				$here = interpolate_headers($test->{header}, $here);
			}
		}
		print $here;
		exit(0);
	} else {
		# increment number of tests run counter
		$test_runs += 1;

		# Results are stored in an array with all newlines removed
		my $results;
		my $outword = "ok  ";
		my $skip_msg;
		
		my $ver = get_required_version($test);
		if($ver && $ver =~ /^[0-9.]*$/ && $VERSION >= $ver) {
			if(is_test_enabled($test)) {
				$results = run_test($test);
				clean_results($test, $results);
				$test->{success} = check_results($test, $results);
				if($test->{success}) {
					$test_successes += 1;
				} else {
					$test_failures += 1;
					$outword = "FAIL";
				}
			} else {
				$outword = 'dis ';
				$skip_msg = $test->{file} . " says that it is disabled.\n";
			}
		} else {
			$outword = 'skip';
			$skip_msg = $test->{file} . " says it requires tmtest version $ver " .
				"but this is only version $VERSION.\n";
		}

		if($dump_results) {
			if($results) {
				print_results($test, $results);
			} else {
				print $skip_msg;
			}
		} elsif($diff_results) {
			if($results && !$test->{success}) {
				diff_results($test, $results);
			}
		} else {
			print("$outword " . $test->{file} . "\n");
		}
	}
}


# This is the same as shellwords.pl, but modified to not strip single
# and double quotes or escaping backslashes, and to break tokens on pipes.

sub subtle_shellwords
{
	local($_) = join('', @_) if @_;
	my @words;

	s/^\s+//;
	while ($_ ne '') {
		my $field = '';
		my $pipe = 0;
		my $here = '';
		my $snippet = '';
		for (;;) {
			use re 'taint'; # leave strings tainted
			if (s/^"(([^"\\]|\\.)*)"//) {
				$snippet = "\"$1\"";
			} elsif (/^"/) {
				die "Unmatched double quote: $_\n";
			} elsif (s/^'(([^'\\]|\\.)*)'//) {
				$snippet = "'$1'";
			} elsif (/^'/) {
				die "Unmatched single quote: $_\n";
			} elsif (s/^\s*\|\s*//) {
				$pipe = 1;
				last;
			} elsif (s/^(\S+)(\<\<\S+)\s//) {
				$field .= $1;
				$here = $2;
				last;
			} elsif (s/^([^\s'"|]+)//) {
				$snippet = $1;
			} else {
				s/^\s+//;
				last;
			}
			$field .= $snippet;
		}
		push(@words, $field);
		push(@words, '|') if $pipe;
		push(@words, $here) if $here;
	}
	@words;
}


# Call this if you need to bail while parsing a testfile.

sub parse_die
{
	my $file = shift;
	my $line = shift;
	my $msg = shift;

	$line += 1;

	die "$file line $line\: $msg";
}


# Still suffering from legacy...  We handle the easy here doc case,
# then try to handle the harder pipe case.  The end result is the
# correct behavior, but the code is, erm, convoluted.

sub has_here_doc
{
	my $cmd = shift;
	my $filename = shift;
	my $line = shift;

	# need to collect the command line into tokens like the shell would
	my @words = subtle_shellwords($cmd);
	$debug && print "cmdWords: '" . join("', '", @words) . "'\n";

	my($pipe, $cmdbeg, $strip_tabs, $here_word, $cmdtrail);

	my $isfile = ($cmd =~ /^\s*((?:\S|\\\s)+)\s*\=\s*(\S.*)?$/ ? 1 : 0);

	# now we ensure that the here doc is associated with the first
	# command in the pipe.  As a side effect, we construct cmdbeg
	# to contain all the tokens except for the here doc word.
	foreach(@words) {
		 /^\|$/ and $pipe++;
		 if($here_word) {
			 $cmdtrail .= ' ' if $cmdtrail && length($cmdtrail);
			 $cmdtrail .= $_;
		 }
		 if(/^\<\<(\-?)(\w*)(.*)$/) {
			 $pipe and parse_die($filename, $line, "We don't " .
				"support sending here docs deep into a pipeline.\n");
			 $strip_tabs = $1;
			 $here_word = $2;
			 defined($here_word) or parse_die($filename, $line,
				"You must specify a word for the here doc.\n");
			 $3 and parse_die($filename, $line, "Garbage after here word: $3\n");
		 } else {
			 $cmdbeg .= ' ' if $cmdbeg && length($cmdbeg);
			 $cmdbeg .= $_;
		 }
	}

	if($isfile && $cmdtrail) {
		 parse_die($filename, $line, "garbage after here doc: '$cmdtrail'\n");
	}

	# $debug and print "CmdWithoutHereWord: $cmdbeg\n";

	return ($cmdbeg || $cmd, $strip_tabs, $here_word);
}


sub should_interpolate_proc
{
	my $header = shift;
	my $area = lc shift;

	return 1 if $area =~ /^commands?$/i;
	return 1 if $area =~ /^headers?$/i;
	return 0 unless exists $header->{interpolate};

	my $interp = $header->{interpolate}->{value};
	for(split(' ', $interp)) {
		my $str = lc $_;
		return 1 if $area eq $str;
		return 1 if 'everything' eq $str || 'all' eq $str;
		return 1 if $area eq 'files' &&
			("allfiles" eq $str || "all-files" eq $str);
	}

	return 0;
}


sub should_interpolate
{
	my $header = shift;
	my $area = lc shift;

	# this just calls the real routine and prints its output.
	my $val = should_interpolate_proc($header, $area);
	$debug && print "  should_interpolate returned " .
		($val ? "true" : "false") . " for area \"$area\"\n";
	return $val;
}


# used by interpolate_headers -- returns the value of the given
# header in the header list or the empty string if it hasn't been set.

sub get_interp_value
{
	my $hdr = shift;
	my $str = lc shift;
	my $warn = shift;

	my $var = ($warn == 2 ? $str : ($warn == 1 ? "($str)" : "{$str}"));

	if(exists $hdr->{$str}) {
		my $val = $hdr->{$str}->{value};
		$val =~ s/[\r\n]$//g;	# get rid of all trailing newlines
		$debug && print "    interpolating <<<$val>>> for \"\$$var\".\n";
		return $val;
	} else {
		$debug && print "    interpolating empty for \"\$$var\".\n";
		if($warn) {
			print STDERR "WARNING: Tried to interpolate \"\$$var\" but it doesn't exist!\n";
			print STDERR "  Use \"\\\$$str\" to escape it and use it in the command.\n";
			print STDERR "  Use \"\${$str}\" to make it optional.\n";
		}
	}

	return '';
}


# Pass a header collection and a string, and this routine will
# replace all instances of $(header) with the header's value.

sub interpolate_headers
{
	my $hdr = shift;		# all available headers
	my $str = shift;

	# matches a header name.
	my $ltr = '[0-9a-zA-Z_\.\/-]+';

	while($str =~ s/(^|[^\\])\$\{($ltr)\}/$1 . get_interp_value($hdr, $2, 0)/geo) {}
	while($str =~ s/(^|[^\\])\$\(($ltr)\)/$1 . get_interp_value($hdr, $2, 1)/geo) {}
	if( exists($hdr->{"interpolate-bare"}) && is_affirmative($hdr->{"interpolate-bare"}->{value}) ||
		exists($hdr->{"bare-interpolation"}) && is_affirmative($hdr->{"bare-interpolation"}->{value})
	) {
		while($str =~ s/(^|[^\\])\$($ltr)/$1 . get_interp_value($hdr, $2, 2)/geo) {}
	}
	$str =~ s/\\\$/\$/g;
	$str =~ s/\\\\/\\/g;

	return $str;
}


sub read_heredoc
{
	my $line = shift;
	my $file = shift;
	my $filename = shift;
	my $here_word = shift;
	my $strip_tabs = shift;

	my $here = [];
	my $orig = [];

	my $stripper = undef;
	while($$line < @$file && $file->[$$line] ne "$here_word\n") {
		my $ll = $file->[$$line];
		my $llc = $ll;
		push @$orig, $ll;
		chomp $llc;
		if($strip_tabs) {
			if(!defined $stripper && $llc =~ /\S/) {
				# define the whitespace that needs to be stripped
				$llc =~ /^(\s+)\S/;
				$stripper = $1;
			}
			# strip out the whitespace if it's identical
			if(defined($stripper) && substr($llc,0,length $stripper) eq $stripper) {
				substr($llc, 0, length $stripper, '');
				substr($ll, 0, length $stripper, '');
			}
		}
		$debug && print "heredoc: $ll";
		push @$here, $ll;
		$$line += 1;
	}

	$$line >= @$file and parse_die($filename, $$line,
		"did you forget to terminate the here doc?\n");
	$debug && print "hereend: $file->[$$line]";

	return ($here, $orig);
}


# Reads the test out of the given file and returns it as a test structure.
# Always succeeds (calls die() if the file can't be read).

sub read_test_file
{
	my $file = shift;
	my $path = shift;
	my $isterminal = shift;

	# read the test file into the $file string
	open( TEST, "<$file" ) or die "Could not open $file\: $!\n";
	my @lines = <TEST>;
	close TEST;

	return read_test(\@lines, $file, $path, $isterminal);
}


# This awful function takes an array of lines representing a test file
# and parses it into a test data structure.  It was never, ever supposed
# to grow this big.  Arg!
# The somewhat odd header syntax (is it a header? is it a comment?) also
# makes this routine weird.

# It's rather funny.  tmtest started with comments and a single test,
# so no continuations were needed.  When I added multiple tests, I
# used indentation to continue.  Then I added headers, which I hacked
# in to use \ for continuation.  Then I realized that was exactly
# backwards and fixed it without rewriting it.  And that is why read_test
# is so completely bonkers.

sub read_test
{
	my $file = shift;
	my $filename = shift;
	my $path = shift;
	my $isterminal = shift;		# true if we require an exit clause

	local $/ = "\n";

	# now scan the string and store the parts in %test
	my $test = {};
	my $line = 0;

	$test->{"file"} = $filename; # filename of this test file
	$test->{"headers"} = [];	# headers explicitly declared by this test
	$test->{"desc"} = [];
	$test->{"command"} = [];
	$test->{"rdesc"} = [];
	$test->{"stdout"} = "";
	$test->{"stderr"} = "";

	$test->{header} = {};		# hash of all headers (both in this test and inherited)

	# prepopulate the headers from relevant config files
	if($isterminal) {
		for my $conf (get_configs($path)) {
			for(keys %{$conf->{header}}) {
				$test->{header}->{$_} = $conf->{header}->{$_};
			}
		}
	}
	
	# add the default headers
	$test->{header}->{'curfile'} = { key => 'curfile', value => $filename };
	$test->{header}->{'curpath'} = { key => 'curpath', value => $path };

	print "\n...   Parsing $filename   ...\n\n" if $debug;

	my @desc;

	# read the test headers
	while($line < @$file) {
		my $header;
		my ($here, $orig, $post);
		my $herepre;

		# "hash" refers to the "#" character, not the hash data structure.
		if($file->[$line] =~ /^(\#)?(\s*\S+\s*)\:(.*)$/) {
			# this line definitely looks like a header
			$header = {hash => ($1||''), key => $2, pkey => 1, value => $3};
		} elsif($line == 0 && $file->[$line] =~ /^\#(.*)$/) {
			# grandfathered feature: if the first line is a comment
			# but doesn't look like a header then it is assumed to be
			# the title of the test.
			$header = {hash => '#', key => 'title', pkey => 0, value => $1};
		} elsif($file->[$line] =~ /^\s*(?:\#.*)?$/) {
			# desc is all blank lines or lines beginning with a hash.
			while( $line < @$file && $file->[$line] =~ /^\s*(?:\#.*)?$/) {
				last if $file->[$line] =~ /^(\#)?(\s*\S+\s*)\:(.*)$/;
				$debug && print "desc: $file->[$line]";
				push @desc, $file->[$line];
				chomp $desc[-1];
				$line++;
			}
			next;
		} else {
			# we must be done processing the headers.
			last;
		}

		if(0) {
			print "HEADER:\n";
			for (keys %$header) {
				print "  $_: " . $header->{$_} ."\n";
			}
		}

		$header->{desc} = [@desc];
		@desc = ();
		# clean up the key, but preserve the original for when we
		# need to print the test verbatim.
		$header->{origkey} = $header->{key};
		$header->{key} =~ s/^\s*|\s*$//g;
		$header->{origvalue} = $header->{value};
		$header->{value} =~ s/^\s*|\s*$//g;
		$header->{herepre} = $header->{herepost} = "";

		# slurp a here document if the header has one.  The here document
		# key must be the last item on the line.
		if($header->{value} =~ /\<\<(\-?)(\w*)\s*$/) {
			my $strip_tabs = $1;
			my $here_word = $2;
			defined($here_word) or parse_die($filename, $line,
					"You must specify a word for the here doc.\n");
			$line += 1;
			($here, $orig) = read_heredoc(\$line, $file, $filename, $here_word, $strip_tabs);
			$post = $file->[$line];
			$line += 1;
		} else {
			# slurp any lines continued by indenting
			# You can't use continuations and heredocs in the same header.
			# Too hard to sort the ambiguity until a rewrite happens.
			while($file->[$line+1] && $file->[$line+1] =~ /^\s/) {
				$line += 1;
				my $val = $file->[$line];
				chomp $val;
				$header->{origvalue} .= "\n" . $val;
				$val =~ s/^\#?\s*//;
				$header->{value} .= (defined($header->{value}) &&
					length($header->{value}) ? "\n" : "") . $val;
			}
		}

		if($debug) {
			print "Reading header \"" . $header->{key} . "\" with a ";
			if(defined($here)) {
				my $cnt = @$here;
				print "$cnt line heredoc.\n";
			} else {
				my $cnt = ($header->{origvalue} =~ tr/\n//);
				print "$cnt line continuation.\n";
			}
		}

		# crfile magic.  this stores crfiles when declared in header.
		# we store the crfiles declared in the body below.

		# Ensure that we only check for the heredoc in the first line of the header
		$header->{value} =~ /^([^\n]*)(.*)$/s;
		my($hdrline, $hdrrest) = ($1, $2);

		if($hdrline =~ /^\s*(exec)?file(?:$|\s*=)/i) {
			if($hdrrest =~ /\S/) {
				parse_die($filename, $line,
					"We don't support multi-line file declarations.\n");
			}
			unless($hdrline =~ /^\s*(exec)?file\s*(?:\=\s*\<\<\S+)?\s*$/) {
				parse_die($filename, $line,
					"Couldn't understand file specification: \"" . trimnl($hdrline) . "\"\n");
			}
			my $name = $header->{key};
			my $args = $2;
			my $exec = (defined($1) && length($1) ? 1 : 0);
			my $parms = {
				desc => $header->{desc},
				pre => [$header->{origkey} . ":" . $header->{origvalue}],
				cmd => $header->{value},
				executable => $exec,
				name => $name, crfile => 1
			};
			if(defined $here) {
				# file content is defined by a heredoc
				$parms->{here} = $here;
				$parms->{orighere} = $orig;
				$parms->{herepost} = $post;
			} else {
				$args and length($args) and parse_die($filename, $line,
					"tmtest doesn't currently support specifying files other than by heredocs\n");
				# file is defined to be empty
				$parms->{pre} = [trimnl($header->{origkey} . ":" . $header->{origvalue})],
			}
			push @{$test->{"cmds"}}, $parms;
			$debug && print "  ...stored in file '$name'\n";
			next;
		}

		if(defined $here) {
			unless($header->{value} =~ /^\s*\<\<(\-?)(\w*)\s*$/) {
				parse_die($filename, $line,
					"If you define a header using a heredoc, the heredoc tag is the only thing that can appear on the same line as the header.\n");
			}
			$header->{herepre} = $header->{origvalue} . "\n";
			$header->{value} = join("", @$here);
			$header->{origvalue} = join("", @$orig);
			$header->{herepost} = $post;
		}

		if(should_interpolate($header, "headers")) {
			my $str = $header->{value};
			$header->{value} = interpolate_headers(
				$test->{header}, $header->{value});
			if($str ne $header->{value}) {
				$debug && print "  old value: " . (defined($str) ? "<<<$str>>>" : "(undef)")  . "\n";
				$debug && print "  new value: <<<" . $header->{value} . ">>>\n";
			} else {
				$debug && print "  but interpolating didn't change the header's value.\n";
			}
		}

		$debug && print "  ... stored header \"" . $header->{key} . "\".\n";
		push @{$test->{headers}}, $header;

		my $key = lc $header->{key};
		if($key eq 'include') {
			my($file, $dir) = File::Basename::fileparse($header->{value});
			my $subt = eval {
				read_test_file($header->{value}, File::Spec->rel2abs($dir), 0);
			};
			parse_die($filename, $line, $@) if $@;
			for(keys %{$subt->{header}}) {
				$test->{header}->{$_} = $subt->{header}->{$_};
			}
		} else {
			$test->{header}->{$key} = $header;
		}
		$line += 1;
	}

	# Now we read any number of commands and files until we hit the
	# output clause.
	while($line < @$file) {
		$debug && print((@desc ? "... continuing desc in" : "begin") . " block...\n");

		# desc is all blank lines or lines beginning with a hash.
		while( $line < @$file && $file->[$line] =~ /^\s*(?:\#.*)?$/ ) {
			$debug && print "desc: $file->[$line]";
			push @desc, $file->[$line];
			chomp $desc[-1];
			$line++;
		}

		last unless $line < @$file;
		
		# if this line begins with 4 dashes, we know it's the start
		# of the output clause.
		last if $file->[$line] =~ /^\-\-\-\-/;

		my @command = ();
		# header hack -- different continuation if it's a header vs. a command.
		# luckily we don't allow continued file headers.  Needs a rewrite.
		if($file->[$line] =~ /^\s*\S+\s*\:\s*(?:exec)?file(.*)$/ &&
			defined($1) && $1 !~ /\<\<\S/)
		{
			# File declaration without a heredoc.  Need to check for continuation.
			if($file->[1+$line] =~ /^\s+\S/) {
				parse_die($filename, $line,
					"We don't support multi-line file declarations.\n");
			}
			push @command, $file->[$line];
			chomp $command[-1];
			$line += 1;
		} else {
			# not a header
			# collect all lines that end with a continuation char
			while($line < @$file) {
				push @command, $file->[$line];
				chomp $command[-1];
				last unless $file->[$line++] =~ /\\\s*$/;
			}
		}

		# convert the command into a single line
		my $cmd = '';
		for my $l (@command) {
			$_ = $l;
			s/^\s+//;
			s/\s*\\\s*$//;
			$cmd .= ' ' if length $cmd;
			$cmd .= $_;
		}
		$debug && print "command: $cmd\n";

		# did the previous line contain a here document?  if so, collect it.
		my $orig = undef;	# orignal here document, w/o tab stripping
		my $here = undef;	# tab-stripped here document
		my $post;		# the heredoc terminator
		
		my ($cmdbeg, $strip_tabs, $here_word) = has_here_doc($cmd, $filename, $line);
		if($here_word) {
			($here, $orig) = read_heredoc(\$line, $file, $filename, $here_word, $strip_tabs);
			$post = $file->[$line];
			$line += 1;
		}

		# the previous block must have either been a command or a file.
		# now decide which one and store it appropriately.
		if($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file/) {
			my $name = $1;
			my $exec = (defined($2) && length($2) ? 1 : 0);
			my $parms = {
				desc => [@desc],
				pre => [@command],
				cmd => $cmd,
				executable => $exec,
				name => $name,
				crfile => 1
			};

			if($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file\s*$/) {
				# empty file -- do nothing
			} else {
				# hereword has already been stripped and heredoc slurped.
				unless($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file\s*\=\s*$/) {
					parse_die($filename, $line,
						"Couldn't understand file specification: \"$cmdbeg\"\n");
				}
				$parms->{here} = $here;
				$parms->{orighere} = $orig;
				$parms->{herepost} = $post;
			}

			push @{$test->{"cmds"}}, $parms;
			$debug && print "  ...stored in file '$name'\n";
		} else {
			push @{$test->{cmds}}, {
				desc => [@desc], command => [@command], cmd => $cmdbeg,
				here => $here, orighere => $orig, herepost => $post,
			};
			$debug && print "  ...stored as command " . @{$test->{cmds}} . "\n";
		}

		@desc = ();
	}

	# if the last item from the above loop is a desc, then it must
	# be the results descriptor.
	if(@desc) {
		$debug && print "  ...stored in rdesc\n";
		$test->{"rdesc"} = \@desc;
	}

	return $test unless $isterminal;

	if($line >= @$file) {
		# no exit clause!  fake an empty one.
		$debug && print "no exit clause!  done parsing.\n";
		$test->{"exitvalue"} = 0;
		return $test;
	}

	$file->[$line] =~ /^[^-]/o and
		parse_die($filename, $line, "expecting the exit clause. did you forget a continuation character?\n" .
		"    '" . $file->[$line] . "'\n");

	# Error always comes before output if it exists.
	if( $file->[$line] =~ /^\-\-\-\-+\s*STDERR:/o ) {
		$line += 1;
		until( $line >= @$file || $file->[$line] =~ /^\-\-\-\-/ ) {
			$debug && print "error: " . $file->[$line];
			$test->{stderr} .= $file->[$line];
			$line += 1;
		}
		$line >= @$file && parse_die($filename, $line, "Could not find output clause.\n");
	}

	# output clause
	my $cltmp = $file->[$line];
	chomp $cltmp;	# i hate that chomp modifies its var instead of returning it
	$file->[$line] =~ /^\-\-\-\-+\s*STDOUT\:(.*)$/io or die
		"Could not parse $filename line $line: malformed output clause:\n" .
		"    '$cltmp'\n";
	$line += 1;

	if($1 =~ /[^0-9]*([0-9]+)[^0-9]*/) {
		$test->{"exitvalue"} = $1;
	} else {
		$test->{"exitvalue"} = 0;
	}
	$debug && print "exitval: " . $test->{"exitvalue"} . "\n";

	while($line < @$file) {
		$debug && print "output: " . $file->[$line];
		$test->{stdout} .= $file->[$line];
		$line += 1;
	}

	$debug && print "done parsing.\n";
	return $test;
}


# Prints all the internal data structures for the test.

sub print_test
{
	my $test = shift;

	print "testfile: $test->{file}\n";
	for my $header (@{$test->{headers}}) {
		print($header->{key} . ': ' . $header->{value} . "\n");
		if($header->{desc} && @{$header->{desc}}) {
			print $header->{key} . "-descr:\n";
			for(@{$header->{desc}}) { print "  $_\n"; }
		}
	}

	my $i = 1;
	for my $cs (@{$test->{cmds}}) {
		if($cs->{crfile}) {
			print "file: " . $cs->{name} .
				($cs->{executable} ? "   (executable)" : "") . "\n";
			print "file-descr:\n";
			for(@{$cs->{desc}}) { print "  $_\n"; }
			print "file-contents:\n";
			if(defined $cs->{here}) {
				for(@{$cs->{here}}) { print "  $_"; }
			}
		} else {
			print "command $i\:\n";
			for(@{$cs->{command}}) { print "  $_\n"; }
			if(defined $cs->{here}) {
				for(@{$cs->{here}}) { print "  $_"; }
			}
			print "command-descr:\n";
			for(@{$cs->{desc}}) { print "  $_\n"; }
			$i += 1;
		}
	}

	print "result descr:\n";
	for(@{$test->{rdesc}}) { print "  $_\n"; }

	print "logfile:";
	for(split('\n', $test->{stderr})) { print "\n  $_"; }
	print "\n";

	print "exit status: " . $test->{exitvalue} . "\n";

	print "result:";
	for(split('\n', $test->{stdout})) { print "\n  $_"; }
	print "\n";
}


# This prints a test file to stdout, replacing the old results
# with the newly generated results.  If new results are identical
# to old, this should result in effectively no difference between the
# old test file and new, including whitespace.
# NOTE: the files will be re-ordered into alphabetical order.  It's a feature. :)

sub print_results
{
	my $test = shift;
	my $results = shift;

	my $exitval = ($results->{"exitvalue"} != 0 ?
		"exit code " . $results->{"exitvalue"} . " - abort!" :
		"exit code 0 - no error");

	for my $header (@{$test->{headers}}) {
		if($header->{desc}) {
			for(@{$header->{desc}}) { print "$_\n"; }
		}
		print(($header->{hash} || '') .
			($header->{pkey} ? $header->{origkey}.':' : '') .
			$header->{herepre} . $header->{origvalue} .
			$header->{herepost} . "\n");
	}
	for my $cs (@{$test->{cmds}}) {
		for(@{$cs->{desc}}) { print "$_\n"; }
		if($cs->{crfile}) {
			for(@{$cs->{pre}}) { print "$_\n"; }
		} else {
			for(@{$cs->{command}}) { print "$_\n"; }
		}
		if(defined $cs->{orighere}) {
			for(@{$cs->{orighere}}) { print "$_"; }
			print $cs->{herepost};
		}
	}
	for(@{$test->{rdesc}}) { print "$_\n"; }
	if(length($results->{stderr})) {
		print "------ STDERR:\n";
		print $results->{stderr};
		# need to add a newline to separate the output sections
		# even if there wasn't a newline in the actual output.
		print "\n" unless $results->{stderr} =~ /\n$/;
	}
	print "------ STDOUT: $exitval\n";
	print $results->{stdout};
	# but no need to print a newline here.  user will be able to see
	# if test ends in a newline or not.
}


sub diff_results
{
	my $test = shift;
	my $results = shift;

	open(FD, "|-", $diff, "-u", $test->{file}, "-")
		or die "Couldn't start $diff: $!\n";
	my $oldfd = select(FD);
	print_results($test, $results);
	select($oldfd);
	close(FD);

	# diff returns an exit code of 0 if the files are identical,
	# 1 if they're different, and 2 if there was an error.  So,
	# we'll assume success if it returns 0 or 1 and didn't signal or core.
	die "$diff returned $?: $!\n" unless $? == (0<<8) || $? == (1<<8);
}


# Reads a file, line-by-line, into an anonymous array.
sub read_file
{
	my $name = shift;

	my $arr = [];

	open(FH, "<$name") or die "Could not open file $name: $!\n";
	while(<FH>) { chomp; push @$arr, $_ ; }
	close FH;

	return $arr;
}


# checks the command to see if it's one that should be substituted
# and, if so, performs the substitution.

sub do_cmd_sub
{
	my $sub = shift;	# specifies what substitutions to perform
	my $cmd = shift;	# the string to substitute

	# do the substitutions
	for(keys %{$sub}) {
		if($cmd eq $_) {
			my $quote = '';
			$quote = '"' if $sub->{$_} =~ /\s/;
			return $quote.$sub->{$_}.$quote;
		}
	}

	return $cmd;
}


# Applies all relevant executable headers to determine exactly
# what command we should run.

sub get_executable_command
{
	my $test = shift;
	my $cs = shift;

	my $str = '';
	my $cmd = $cs->{cmd};
	if(exists $test->{header}->{executable}) {
		# separate out each executable
		my %sub;
		for(shellwords($test->{header}->{executable}->{value})) {
			my($key, $val) = /^([^=]+)=(.*)$/
				or die "Needs an '=' (cmd=path/to/cmd): $_\n";
			$sub{$key} = $val;
		}

		# split the string as the shell would.  Then, the first word
		# and the first word after each pipe char is the command.
		my @words = subtle_shellwords($cmd);
		for(@words) {
			$str .= ' ' if length($str);
			$str .= do_cmd_sub(\%sub, $_, $test->{header});
		}
	} else {
		$str = $cmd;
	}

	if(should_interpolate($test->{header}, "commands")) {
		my $old = $str;
		$str = interpolate_headers($test->{header}, $str);
		if($old ne $str) {
			$debug && print "  old value: " . (defined($old) ? "<<<$old>>>" : "(undef)")  . "\n";
			$debug && print "  new value: <<<$str>>>\n";
		} else {
			$debug && print "  but interpolating didn't change the command's value.\n";
		}
	}

	return trimnl($str);
}


# Returns the heredoc as a string if it exists, undef if it doesn't.

sub get_heredoc
{
	my $cs = shift;
	my $hdr = shift;

	if(exists $cs->{here} && defined $cs->{here}) {
		my $val = join('', @{$cs->{here}});
		$val = interpolate_headers($hdr, $val) if $hdr;
		return $val;
	}

	return undef;
}


sub create_crfile
{
	my $file = shift;
	my $test = shift;
	my $dstfile = shift;

	my $name = $file->{name};

#	my $extension = "";
#	if($name =~ /(\.[^\/]+)$/) {
#		$extension = $1;
#	}

	my $template = "tmtest-$$.XXXXXX";

	# check to see if filename includes path operations
	if($name =~ /^(.*\/)?([^\/]*)$/) {
		die "Illegal file name \"$name\"\n" unless defined($2) && length($2);
		$template = undef if $1;
	}

	my $fh;
	if($template) {
		if($dstfile) {
			$name = $dstfile;
			open($fh, ">$name") or die "Could not create $name\: $!\n";
		} else {
			($fh, $name) = File::Temp::tempfile($template,
				SUFFIX => ".$name", DIR => File::Spec->tmpdir);
		}
	} else {
		open($fh, ">$name") or die "Could not create $name\: $!\n";
	}
	$debug && print "  created file: '$name'\n";
	my $header;
	if(	should_interpolate($test->{header}, $file->{name}) ||
		should_interpolate($test->{header}, "files") ||
		($file->{executable} && should_interpolate($test->{header}, "execfiles"))
	) {
		$header = $test->{header};
	}

	my $here = get_heredoc($file, $header);
	$debug && print "  filled it with <<<$here>>>\n";
	print $fh $here if defined $here;
	close $fh;

	if($file->{executable}) {
		$debug && print "   ... and marked it executable.\n";
		# leave permissions as-is except mark all executable.
		chmod( ((stat($name))[2])|0777, $name );
	}

	return $name;
}


sub run_test
{
	my $test = shift;

	my $result = {
			"stdout" => "",		# aggregated stdout
			"stderr" => "",		# aggregated stderr
			"exitvalue" => 0,	# nonzero if any command returned an error
		};

	my %unlink = ();

	print "\n...   Running Tests   ...\n\n" if $debug;

	my $index = 0;
	for my $cs (@{$test->{cmds}}) {

		$debug && print "Reading command " . ++$index . ".\n";

		if($cs->{crfile}) {
			my $name = create_crfile($cs, $test);
			# add the created file to the headers
			$debug && print "  added header \"" . $cs->{name} . "\" value \"$name\"\n";
			$test->{header}->{lc $cs->{name}} = {value => $name};
			$unlink{$name}++;
			next;
		}

		my $cmd = get_executable_command($test, $cs);
		my $here = get_heredoc($cs, should_interpolate($test->{header}, "stdin") ?
				$test->{header} : undef);

		my (undef, $stdout) = File::Temp::tempfile("tmtest.$$.XXXXXX",
			SUFFIX => ".stdout", DIR => File::Spec->tmpdir);
		my (undef, $stderr) = File::Temp::tempfile("tmtest.$$.XXXXXX",
			SUFFIX => ".stderr", DIR => File::Spec->tmpdir);

		if($debug) {
			print "  output to $stdout\n  error to $stderr\n";
			if(defined($here)) { 
				print "  feeding on stdin: <<<$here>>>\n";
			} else {
				print "  not passing anything to command on stdin.\n";
			}
		}

		# can't use Perl open or system calls because we need to
		# redirect stdout and stderr before execing.

		$SIG{PIPE} = 'IGNORE';
		$SIG{ABRT} = sub { die "child aborted!\n" };
		pipe RH,WH;
		$debug && print "  Running command: $cmd\n";
		my $pid = fork();
		if($pid == 0) {
			# child
			open(STDIN, "<&RH") or die "Chid coudln't open stdin: $!\n";
			close WH;
			close RH;
			open(STDOUT, ">$stdout") or die "Child couldn't open $stdout\: $!\n";
			open(STDERR, ">$stderr") or die "Child couldn't open $stderr\: $!\n";
			exec('/bin/sh', '-c', $cmd);
			die "Could not exec /bin/sh -c (cmd): $!\n";
		}

		# parent
		close RH;
		if(defined $here) {
			print WH $here or die "Could not write: $!\n";
		}
		#  don't check for error -- it should appear in test results.
		close WH;  # or die "Could not close pipe: $!\n";
		waitpid($pid,0);

		die "Exit value is -1: couldn't run command: $!\n" if $? == -1;

		my $exit_value  = $? >> 8;
		my $signal_num  = $? & 127;
		my $dumped_core = $? & 128;

		# If sigint was raised on child, raise sigint on tmtest.
		# Otherwise it can be very difficult to cancel a test.
		# We won't raise ther signals like ABRT (i.e. assert()) on tmtest.
		if($signame[$signal_num] eq 'INT') {
			kill $signal_num => $$;
		}

		if($signal_num && $debug) {
			print "CHILD DIED BY SIGNAL $signal_num: SIG" .
				$signame[$signal_num] . "\n";
		}

		if( $exit_value_hack ) {
			# This is a gross, awful, kludgy hack.  @-n needs to return
			# nonzero so that if it's accidentally set when fetchmail
			# runs, fetchmail bails immediately without losing any mail.
			# So, it returns 121 if trestlemail WOULD have succeeded if
			# it wasn't for @-n.   This is Trestlemail ONLY!
			$exit_value = 0 if $exit_value == 125;
		}
		
		$result->{stdout} .= slurp_file($stdout) if -f $stdout;
		$result->{stderr} .= slurp_file($stderr) if -f $stderr;
		$result->{exitvalue} = $exit_value;

		if(-f $stdout) {
			unlink $stdout or die "Couldn't unlink $stdout: $!\n";
			$debug && print "  Removed $stdout\n";
		}
		if(-f $stderr) {
			unlink $stderr or die "Couldn't unlink $stderr: $!\n";
			$debug && print "  Removed $stderr\n";
		}

		last if $exit_value or $signal_num;
	}

	# delete the transient files
	if(keys %unlink) {
		my $num = unlink(keys %unlink);
		$debug && print "Removed $num files: (" . join(", ", keys %unlink) . ")\n";
		$debug && $num != (keys %unlink) && print "   Error was: $!\n";
	}

	$debug && print "Done running tests!\n\n";

	return $result;
}


sub check_results
{
	my $test = shift;
	my $results = shift;

	# return 0 if they differ, 1 if the same
	return 0 if
		$test->{"stdout"} ne $results->{"stdout"} ||
		$test->{"stderr"} ne $results->{"stderr"} ||
		$test->{"exitvalue"} != $results->{"exitvalue"};

	return 1;
}

