#!/usr/bin/perl -w

# tmtest
# Scott Bronson
# 14 Sept 2000

#
# How to use this tool:
#
# test              : - no arguments runs all tests
#                   : - a single filename of "-" takes test from stdin
#		otherwise, specify the tests to run on the command line
#		if you specify a directory, it will recursively run all
#		tests in the directory.
#   -o              : output test, print test to stdout rather than running
#   -d              : output diff between the expected and actual test output.
#   -c              : simply syntax check the test file
# 


use strict; 
use Getopt::Std;
use File::Basename;
use FindBin qw($Bin);
use Cwd 'abs_path';

use vars qw( $VERSION );
$VERSION = "0.4";

use vars qw( $tmtestpath $config $exit_value_hack );	# supplied to config
use vars qw( $output $error $output_re $error_re $exit_code_re );
use vars qw( $generate_exit_msg $clean_results );
use vars qw( $executable $executablepath );

# prepare defaults for all customization values
# the only one that tmtest-config MUST set is $executable
$executable = undef;
$tmtestpath = $Bin;
$config = "$Bin/tmtest-config";
$exit_value_hack = 0;
$output = "STDOUT";
$output_re = $output;
$error = "STDERR";
$error_re = $error;
$exit_code_re = "(?:exit code: (\\d+))?";
$generate_exit_msg = sub {
	my $code = shift;
	return ($code ? "exit code: $code" : "");
};
$clean_results = sub { };
$executablepath = undef;

# Read customization file
-r $config || die "$config can't be read.\n";
do $config;

die "Config file must set \$executable!\n" unless defined $executable;
$executablepath ||= "$Bin/$executable";
-x $executablepath || die "$executablepath does not exist or is not executable.\n";

$| = 1;		# don't buffer stdout

	

my %opts;
unless( getopts( "odcvP", \%opts ) ) {
	die "usage: tmtest [-v] [-o] [test files or dirs...]\n" .
		"       -o: dump the results (rather than just go/nogo)\n" .
		"       -d: diff results against expected results\n" .
		"       -c: syntax check\n";
}

my $dump_results = $opts{"o"};
my $diff_results = $opts{"d"};
my $syntax_check = $opts{"c"};
my $debug = $opts{"P"};	# parse debug

my $test_runs = 0;
my $test_successes = 0;
my $test_dumpstats = 0;

if( @ARGV == 1 && $ARGV[0] eq "-" ) {
	# One last argument is a dash?  Read from stdin.
	my @file = <STDIN>;
	my $test = read_test_file( \@file, "STDIN" );
	process_test( $test );
} elsif(@ARGV) {
	for(@ARGV) {
		if( -f $_ ) {
			# process a single test file
			my($file, $dir) = fileparse($_);
			my $cwd = Cwd::cwd();
			chdir $dir;
			process_test_file($file);
			chdir $cwd;
		} elsif(-d $_) {
			# search this dir and all subdirs for tests
			search_test_dirs($_);
		} else {
			print STDERR "File $_ not found.\n";
		}
	}
} else {
	# If user didn't supply any tests to run,
	# run everything in current dir.
	search_test_dirs(".");
}

if( $test_dumpstats ) {
	my $test_failures = $test_runs - $test_successes;
	print "\n$test_runs test" .
		($test_runs != 1 ? "s" : "") . " run, $test_successes success" .
		($test_successes != 1 ? "es" : "") . ", $test_failures failure" .
		($test_failures != 1 ? "s" : "") . "\n";
}

exit 0;




# Adds the required number of spaces to bring the length of the
# supplied string up to the desired length.
# In small doses, this is easier than using format strings.

sub pad
{
	$_ = shift;
	my $len = shift;

	$_ .= " " x ($len - length) if(length() < $len);
	return $_;
}


# Recursively searches through directories for tests and runs them.
# tmtest used to use File::Find to perform the recursive directory
# search.  However, I now want it to print subdirs as they're 
# entered, and to go in alphabetical order, processing first
# files, then directories.  Therfore, my own dirsearch is needed.

sub search_test_dirs
{
	my $path = shift;
	my $base = shift || $path;

	print "\nProcessing $base/\n";

	# Since we're doing something recursive,
	# we'll print the final count at the end.
	$test_dumpstats = 1;

	if( chdir $path ) {
		opendir( DIR, '.' ) or die "Can't open $path: $!\n";
		my @names = sort readdir( DIR );
		closedir( DIR );

		# first, process files
		for( @names ) {
			next if $_ eq '.' || $_ eq '..';
			-f && process_test_file( $_ );
		}

		# then, process directories
		for( @names ) {
			next unless $_;
			next if $_ eq '.' || $_ eq '..';
			next if $_ eq 'CVS';
			-d && search_test_dirs( $_, "$base/$_" );
		}

		chdir '..';
	} else {
		die "Can't cd to $_: $!\n";
	}
}


# Reads the test from the provided filename and performs the test.
# Assumes cwd is set up so we can immediately start testing.

sub process_test_file
{
	my $filename = shift;

	# Skip directories, test files must end in ".test"
	if( !-d && /\.test$/ ) {
		# read the test file into the $file string
		open( TEST, "<$filename" ) or die "Could not open $filename: $!\n";
		my @file = <TEST>;
		close TEST;

		my $test = read_test_file( \@file, $filename );
		process_test( $test );
	}
}


# Given the test structure, performs the test.

sub process_test
{
	my $test = shift;

	if( $syntax_check ) {
		print_test( $test );
	} else {
		# increment number of tests run counter
		$test_runs += 1;

		# Results are stored in an array with all newlines removed
		my $results = run_test( $test );
		&$clean_results( $results );

		my $success = check_results($test, $results);
		$test_successes += 1 if $success;

		if( $dump_results ) {
			print_results( $test, $results );
		} elsif( $diff_results ) {
			diff_results( $test, $results );
		} else {
			my $file = pad( $test->{file}, 30 );
			print( ($success ? "ok  " : "FAIL") . " $file\n" );
		}
	}
}


# This awful function takes an array of lines representing a test file
# and parses it into a test data structure.  It was never, ever supposed
# to grow this big.  It needs to be totally eradicated.

sub read_test_file
{
	my $file = shift;
	my $filename = shift;

	local $/ = "\n";

	# for(@$file) { print "file: $_"; }

	# now scan the string and store the parts in %test
	my $test = {};
	my $line = 0;

	$test->{"author"} = '';
	$test->{"date"} = '';
	$test->{"desc"} = [];
	$test->{"cmds"} = [];
	$test->{"rdesc"} = [];
	$test->{"result"} = [];
	$test->{"logfile"} = [];
	$test->{"files"} = [];


	$test->{"file"} = $filename;

	$file->[$line] =~ /^\#(.*)$/
		or die "$filename line 1: needs to be \"#\" then the test name. No whitespace!\n" .
			"    " . $file->[$line];
	$line += 1;
	$test->{"name"} = $1;

	for( ; $line < @$file ; $line++) {
		# first non-header line causes header parsing to stop
		last if $file->[$line] =~ /^\s*\#?\s*$/;
		# does this line look like "key : value"?
		last unless $file->[$line] =~ /^ \#\s*(\S+)\s*\:(.*)$/x;
		my ($key, $data) = ($1, $2);
		if(lc $key eq 'author') {
			$test->{"author"} = $data;
		} elsif(lc $key eq 'date') {
			$test->{"date"} = $data;
		} else {
			die "$filename line $line\: Unknown header '$key'\n";
		}
	}

	# Now we read any number of commands and files until we hit the
	# output clause.
	my @desc;
	while($line < @$file) {
		$debug && print "begin block...\n";
		@desc = ();

		# desc is all blank lines or lines beginning with a hash.
		while( $line < @$file && $file->[$line] =~ /^\s*(?:\#.*)?$/ ) {
			$debug && print "desc: $file->[$line]";
			push @desc, $file->[$line];
			chomp $desc[-1];
			$line++;
		}

		last unless $line < @$file;
		
		# if this line begins with a dash, we know it's the start
		# of the output clause.
		last if $file->[$line] =~ /^-/;

		# collect all lines that end with a continuation char
		my @command = ();
		while($line < @$file) {
			$debug && print "command: $file->[$line]";
			push @command, $file->[$line];
			chomp $command[-1];
			last unless $file->[$line++] =~ /\\\s*$/;
		}

		# convert the command into a single line
		my $cmd = '';
		for my $l (@command) {
			$_ = $l;
			s/^\s+//;
			s/\s*\\\s*$//;
			$cmd .= ' ' if length $cmd;
			$cmd .= $_;
		}
		$debug && print "cmd: $cmd\n";

		# did the previous line end with a here document?  if so, collect it.
		my @orig = ();	# orignal here document, w/o tab stripping
		my @here = ();	# tab-stripped here document
		my $post;		# the heredoc terminator
		
		my $cmdbeg = $cmd;
		if($cmd =~ /^(.*)\<\<(\-?)(\w+)\s*(?:\s(\S.*))?$/) {
			my(undef, $strip_tabs, $here_word, $illegal) = ($1, $2, $3, $4);
			$cmdbeg = $1;
			die "$filename line $line\: garbage after here doc: '$illegal'\n"
				if $illegal && length($illegal);
			my $stripper = undef;
			while($line < @$file && $file->[$line] ne "$here_word\n") {
				my $ll = $file->[$line];
				chomp $ll;
				push @orig, $ll;
				if($strip_tabs) {
					if(!defined $stripper) {
						# define the whitespace that needs to be stripped
						$ll =~ /^(\s+)/;
						$stripper = $1;
					}
					# strip out the whitespace if it's identical
					if(substr($ll,0,length $stripper) eq $stripper) {
						substr($ll, 0, length $stripper, '');
					}
				}
				$debug && print "heredoc: $ll\n";
				push @here, $ll;
				$line += 1;
			}

			$line >= @$file and die "file $filename line $line\: did you forget to terminate the here doc?\n";
			$debug && print "hereend: $file->[$line]";
			$post = $file->[$line];
			chomp $post;
			$line += 1;
		}

		# the previous block must have either been a command or a file.
		# store it in the appropriate place.
		if($cmdbeg =~ /^\s*((?:\S|\\\s)+)\s*\=\s*(\S.*)?$/) {
			my ($name, $args) = ($1, $2);
			my $exec = 0;
			if(defined $args && length $args) {
				if($args =~ /^\s*\+x\s*$/) {
					$exec = 1;
				} else {
					die "$filename line $line\: garbage in file declaration: '$args'\n"
						if $args && length $args;
				}
			}

			push @{$test->{"files"}}, {
				desc => [@desc], pre => [@command], cmd => $cmd,
				content => [@here], orig => [@orig], post => $post,
				executable => $exec, name => $name,
			};
			$debug && print "  ...stored in file '$name'\n";
		} else {
			push @{$test->{cmds}}, {
				desc => [@desc], command => [@command], cmd => $cmd,
				here => [@here], orighere => [@orig], herepost => $post,
			};
			$debug && print "  ...stored as command " . @{$test->{cmds}} . "\n";
		}

		@desc = ();
	}

	# if the last item from the above loop is a desc, then it must
	# be the results descriptor.
	if(@desc) {
		$debug && print "  ...stored in rdesc\n";
		$test->{"rdesc"} = \@desc;
	}

	$line >= @$file and die "file $filename line $line\: unexpected end of input.\n";
	$file->[$line] =~ /^[^-]/o and
		die "file $filename line $line\: expecting the exit clause. did you forget a continuation character?\n" .
		"    '" . $file->[$line] . "'\n";

	# Error always comes before output if it exists.
	if( $file->[$line] =~ /^\-\-\-\-+\s*$error_re:/o ) {
		$line += 1;
		until( $line >= @$file || $file->[$line] =~ /^\-\-\-\-/ ) {
			$debug && print "error: " . $file->[$line];
			push @{$test->{"logfile"}}, $file->[$line];
			chomp $test->{"logfile"}->[-1];
			$line += 1;
		}
		$line >= @$file && die "file $filename line $line: Could not find output clause.\n";
	}

	# output clause
	my $cltmp = $file->[$line];
	chomp $cltmp;	# i hate that chomp modifies its var instead of returning it
	$file->[$line] =~ /^\-\-\-\-+\s*$output_re\:\s*$exit_code_re/o or die
		"Could not parse $filename line $line: malformed Output clause:\n" .
		"    '$cltmp'\n";
	$line += 1;
	$debug && print "exitval: " . ($1 || 0) . "\n";
	$test->{"exitvalue"} = $1 || 0;

	while($line < @$file) {
		$debug && print "output: " . $file->[$line];
		push @{$test->{"result"}}, $file->[$line];
		chomp $test->{"result"}->[-1];
		$line += 1;
	}

	$debug && print "done parsing.\n";
	return $test;
}


# Prints all the internal data structures for the test.

sub print_test
{
	my $test = shift;

	print "name:$test->{name}\n";
	print "author:$test->{author}\n";
	print "date:$test->{date}\n";
	print "from: $test->{file}\n";

	for my $file (@{$test->{files}}) {
		print "file: " . $file->{name} .
			($file->{executable} ? "   (executable)" : "") .  "\n";
		print "file-descr:\n";
		for(@{$file->{desc}}) { print "  $_\n"; }
		print "file-contents:\n";
		for(@{$file->{content}}) { print "  $_\n"; }
	}

	my $i = 1;
	for my $cs (@{$test->{cmds}}) {
		print "command $i\:\n";
		for(@{$cs->{command}}) { print "  $_\n"; }
		for(@{$cs->{here}}) { print "  $_\n"; }
		print "  ".$cs->{herepost}."\n" if @{$cs->{here}};
		print "command-descr:\n";
		for(@{$cs->{desc}}) { print "  $_\n"; }
		$i += 1;
	}

	print "result descr:\n";
	for(@{$test->{rdesc}}) { print "  $_\n"; }

	print "logfile:\n";
	for(@{$test->{logfile}}) { print "  $_\n"; }

	print "exit status: $test->{exitvalue}\n";

	print "result:\n";
	for(@{$test->{result}}) { print "  $_\n"; }
}


# This prints a test file to stdout, replacing the old results
# with the newly generated results.  If new results are identical
# to old, this should result in effectively no difference between the
# old test file and new, including whitespace.
# NOTE: the files will be re-ordered into alphabetical order.  It's a feature. :)

sub print_results
{
	my $test = shift;
	my $results = shift;

	my $exitval = &$generate_exit_msg( $results->{"exitvalue"} );

	print "#$test->{name}\n";
	print "# author:$test->{author}\n" if length $test->{author};
	print "# date:$test->{date}\n" if length $test->{date};
	for my $file (@{$test->{files}}) {
		for(@{$file->{desc}}) { print "$_\n"; }
		for(@{$file->{pre}}) { print "$_\n"; }
		print join("\n", @{$file->{orig}});
		print "\n" if @{$file->{orig}};
		print $file->{post}."\n" if defined $file->{post} && length $file->{post};
	}
	for my $cs (@{$test->{cmds}}) {
		for(@{$cs->{desc}}) { print "$_\n"; }
		for(@{$cs->{command}}) { print "$_\n"; }
		for(@{$cs->{orighere}}) { print "$_\n"; }
		print $cs->{herepost}."\n" if exists $cs->{here} && @{$cs->{here}};
	}
	for(@{$test->{rdesc}}) { print "$_\n"; }
	if(@{$results->{"logfile"}}) {
		print "------ $error:\n";
		for(@{$results->{"logfile"}}) { print "$_\n"; };
	}
	print "------ $output: $exitval\n";
	for(@{$results->{"result"}}) { print "$_\n"; }
}


# Passed references to two arrays of lines, dumps the arrays out
# to temporary files and runs diff on them.  We just allow diff
# to print to our stdout.

sub diff_arrays
{
	my $old = shift;
	my $new = shift;

	my $oldname = "/tmp/tmtest-$$-expects";
	my $newname = "/tmp/tmtest-$$-results";

	open OLD, ">$oldname" or die "Could not open $oldname: $!\n";
	for(@$old) { print OLD "$_\n"; }
	close OLD;

	open NEW, ">$newname" or die "Could not open $newname: $!\n";
	for(@$new) { print NEW "$_\n"; }
	close NEW;

	system( "diff", "-u", $oldname, $newname)
		or die "Could not execute diff: $!\n";

	unlink $oldname or die "Could not unlink $oldname: $!\n";
	unlink $newname or die "Could not unlink $newname: $!\n";
}


sub diff_results
{
	# returns 0 if they differ, 1 if the same
	my $test = shift;
	my $results = shift;
	my $same = 1;

	if( !compare_arrays($test->{"logfile"}, $results->{"logfile"}) ) {
		$same = 0;
		print "------ $error:\n";
		diff_arrays( $test->{"logfile"}, $results->{"logfile"} );
	}

	if( !compare_arrays($test->{"result"}, $results->{"result"}) ) {
		$same = 0;
		print "------ Output:\n";
		diff_arrays( $test->{"result"}, $results->{"result"} );
	}

	if( $test->{"exitvalue"} != $results->{"exitvalue"} ) {
		$same = 0;
		print "Exit values differ: old=" . $test->{"exitvalue"} .
			" new=" . $results->{"exitvalue"} . "\n";
	}

	return $same;
}


# Reads a file, line-by-line, into an anonymous array.
sub read_file
{
	my $name = shift;

	my $arr = [];

	open(FH, "<$name") or die "Could not open file $name: $!\n";
	while(<FH>) { chomp; push @$arr, $_ ; }
	close FH;

	return $arr;
}


sub run_test
{
	my $test = shift;

	# first, create any requested files
	my %unlink = ();
	for my $file (@{$test->{files}}) {
		my $name = $file->{name};
		$unlink{$name}++;
		$debug && print "Creating file: '$name'\n";
		open(FH, ">$name") or die "Could not create $name\: $!\n";
		print FH join("\n", @{$file->{content}}), "\n";
		close FH;
		if($file->{executable}) {
			$debug && print "   ... and marking it executable.\n";
			# leave permissions as-is except mark all executable.
			chmod( ((stat($name))[2])|0777, $name );
		}
	}

	my $result = {
			# organized by command:
			"cmdout" => [],
			"cmderr" => [],
			"cmdexit" => [],
			# aggregated:
			"result" => [],
			"logfile" => [],
			"exitvalue" => 0,
		};

	for my $cs (@{$test->{cmds}}) {
		my $cmd = $cs->{cmd};
		$cmd =~ s/\s*<<\s*\S+\s*$//;
		my $here = undef;
		$here = join("\n", @{$cs->{here}})."\n"
			if exists $cs->{here} && @{$cs->{here}};

		my $stdout = "/tmp/tmtest.$$.".(1+@{$result->{result}}).".stdout";
		my $stderr = "/tmp/tmtest.$$.".(1+@{$result->{result}}).".stderr";

		# Replace program name in test with full path to executable
		$cmd =~ s/$executable\s/$executablepath /;

		$debug && print "Running command: $cmd\n";
		$debug && defined($here) && print "Feeding on stdin: <<<$here>>>\n";

		# can't use Perl open or system calls because we need to
		# redirect stdout and stderr before execing.

		$SIG{PIPE} = 'IGNORE';
		pipe RH,WH;
		my $pid = fork();
		if($pid == 0) {
			# child
			open(STDIN, "<&RH") or die "Chid coudln't open stdin: $!\n";
			close WH;
			close RH;
			open(STDOUT, ">$stdout") or die "Child couldn't open $stdout\: $!\n";
			open(STDERR, ">$stderr") or die "Child couldn't open $stderr\: $!\n";
			exec('/bin/sh', '-c', $cmd);
			die "Could not exec /bin/sh -c (cmd): $!\n";
		}

		# parent
		close RH;
		if(defined $here) {
			print WH $here or die "Could not write: $!\n";
		}
		#  don't check for error -- it should appear in test results.
		close WH;  # or die "Could not close pipe: $!\n";
		waitpid($pid,0);

		die "Exit value is -1: couldn't run command: $!\n" if $? == -1;

		my $exit_value  = $? >> 8;
		my $signal_num  = $? & 127;
		my $dumped_core = $? & 128;


		# If our child got a signal, raise the very same signal on
		# ourselves.  This is so we interrupt cleanly if the
		# user hits interrupt while a test is running.
		$signal_num && kill $signal_num => $$;

		if( $exit_value_hack ) {
			# This is a gross, awful, kludgy hack.  @-n needs to return
			# nonzero so that if it's accidentally set when fetchmail
			# runs, fetchmail bails immediately without losing any mail.
			# So, it returns 121 if trestlemail WOULD have succeeded if
			# it wasn't for @-n.   This is Trestlemail ONLY!
			$exit_value = 0 if $exit_value == 125;
		}
		
		my $cmdout = -f $stdout ? read_file($stdout) : [];
		my $cmderr = -f $stderr ? read_file($stderr) : [];
		# store results individually
		push @{$result->{cmdout}}, $cmdout;
		push @{$result->{cmderr}}, $cmderr;
		push @{$result->{cmdexit}}, $exit_value;
		# store results in aggregate
		push @{$result->{result}}, @$cmdout;
		push @{$result->{logfile}}, @$cmderr;
		$result->{exitvalue} = $exit_value;

		last if $exit_value;
	
		-f $stdout && (unlink $stdout or die "Couldn't unlink $stdout: $!\n");
		-f $stderr && (unlink $stderr or die "Couldn't unlink $stderr: $!\n");
	}

	# don't delete the transient files if the test exited with an error.
	# the user might want to look at them.
	if(keys %unlink) {
		if($? == 0) {
			my $num = unlink(keys %unlink);
			$debug && print "Removed $num files: (" . join(", ", keys %unlink) . ")\n";
			$debug && $num != (keys %unlink) && print "   Error was: $!\n";
		} else {
			$debug && print "Test resulted in an error -- not removing files.\n";
		}
	}

	return $result;
}


sub compare_arrays 
{
	# returns 0 if they differ, 1 if the same
	my ($first, $second) = @_;

	return 0 unless @$first == @$second;

	for( my $i = 0; $i < @$first; $i++ )
	{
		return 0 if
			not defined $first->[$i] or
			not defined $second->[$i] or
			$first->[$i] ne $second->[$i];
	}

	return 1;
}



sub check_results
{
	my $test = shift;
	my $results = shift;

	# return 0 if they differ, 1 if the same
	return 0 if
		!compare_arrays($test->{"logfile"}, $results->{"logfile"}) ||
		!compare_arrays($test->{"result"}, $results->{"result"}) ||
		$test->{"exitvalue"} != $results->{"exitvalue"};

	return 1;
}

