/* main.c
 * 28 Dec 2004
 * Copyright (C) 2004 Scott Bronson
 * This entire file is covered by the GNU GPL V2.
 * 
 * The main routine for tmtest.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <unistd.h>
#include <getopt.h>
#include <dirent.h>
#include <assert.h>

#include "test.h"
#include "qscandir.h"
#include "vars.h"


enum {
    outmode_normal,
    outmode_output,
    outmode_diff
};

int outmode;
int verbose = 0;
double timeout = 10.0;		// timeout in seconds


int g_outfd;
int g_errfd;



// exit values:
enum {
    no_error = 0,
    argument_error,
    runtime_error,
    interrupted_error,
};


#define xstringify(x) #x
#define stringify(x) xstringify(x)


void add_define(char *def)
{
    printf("Adding define %s\n", def);
}


/** Returns zero if s1 ends with s2, nonzero if not.
 */

int strcmpend(const char *s1, const char *s2)
{
    size_t n1 = strlen(s1);
    size_t n2 = strlen(s2);

    if(n2 <= n1) {
        return strncmp(s1+n1-n2, s2, n2);
    } else {
        return 1;
    }
}


/** Prints the given template to the given file, performing substitutions.
 */

void print_template(struct test *test, const char *tmpl,  FILE *fp)
{
    char varbuf[32];
    const char *cp, *ocp, *ce;
    int len;

    for(ocp=cp=tmpl; (cp=strchr(cp,'%')); cp++) {
        if(cp[1] == '(') {
            // perform a substitution
            fwrite(ocp, cp - ocp, 1, fp);
            cp += 2;
            ce = strchr(cp,')');
            if(!ce) {
                fprintf(stderr, "Unterminated template variable: '%.20s'\n", cp);
                exit(runtime_error);
            }
            len = ce - cp;
            if(len <= 0) {
                fprintf(stderr, "Garbage template variable: '%.20s'\n", cp);
                exit(runtime_error);
            }
            // truncate variable name if it doesn't fit into varbuf.
            if(len > sizeof(varbuf)-1) {
                len = sizeof(varbuf)-1;
            }
            memcpy(varbuf, cp, len);
            varbuf[len] = '\0';
            if(printvar(test,fp,varbuf) != 0) {
                // printvar has already printed the error message
                exit(runtime_error);
            }
            ocp = cp = ce+1;
        }
    }

    fputs(ocp, fp);
}


void reset_test(struct test *test)
{
    if(lseek(test->outfd, 0, SEEK_SET) < 0) {
        perror("seeking to beginning of stdout");
        exit(runtime_error);
    }

    if(ftruncate(test->outfd, 0) < 0) {
        perror("resetting stdout");
        exit(runtime_error);
    }

    if(lseek(test->errfd, 0, SEEK_SET) < 0) {
        perror("seeking to beginning of stderr");
        exit(runtime_error);
    }

    if(ftruncate(test->errfd, 0) < 0) {
        perror("resetting stderr");
        exit(runtime_error);
    }
}


int wait_for_child(int child)
{
    int pid;
    int signal;
    int status;

    // wait patiently for child to finish.
    pid = waitpid(child, &status, 0);
    if(pid < 0) {
        perror("waiting for test to finish");
        exit(runtime_error);
    }

    if(WIFSIGNALED(status)) {
        signal = WTERMSIG(status);
        if(signal == SIGINT) {
            // If test was interrupted with a sigint then exit.
            // Otherwise it can be hard to interrupt a test battery.
            exit(interrupted_error);
        }
        // it's probably a SIGABRT if child hit an assertion.
        // we'll just return 256.
        return 256;
    }

    if(!WIFEXITED(status)) {
        fprintf(stderr, "Unknown status returned by child: %d\n", status);
        exit(runtime_error);
    }

    return WEXITSTATUS(status);
}


/** Runs the named testfile.
 *
 * If warn_suffix is true and the ffilename doesn't end in ".test"
 * then we'll print a warning to stderr.  This is used when
 * processing the cmdline args so the user will know why a file
 * explicitly named didn't run.
 *
 * When config files are executing, they use the standard stdout
 * and stderr.  That way, the user sees any output while the test
 * is running (should help with debugging).  However, when the
 * test itself is running, its output is redirected into outfd/errfd.
 */

void run_test(const char *name, int warn_suffix)
{
    struct test test;
    int pipes[2];
    int child;
    int status;
    FILE *tochild;

    // defined in the exec.c file generated by exec.tmpl.
    extern const char exec_template[];

    if(strcmpend(name, ".test") != 0) {
        if(warn_suffix) {
            fprintf(stderr, "%s was skipped because it doesn't end in '.test'.\n", name);
        }
        return;
    }

    memset(&test, 0, sizeof(struct test));
    test.filename = name;
    test.outfd = g_outfd;
    test.errfd = g_errfd;

    // reset the stdout and stderr capture files.
    reset_test(&test);

    // set up the pipe to feed input to the child.
    // ignore sigpipes since we don't want a signal raised if child
    // quits early (which almost always happens since it exits before
    // it reads its expected stdout/stderr).
    signal(SIGPIPE, SIG_IGN);
    if(pipe(pipes) < 0) {
        perror("creating pipe");
        exit(runtime_error);
    }

    // fork child process
    child = fork();
    if(child < 0) {
        perror("forking test");
        exit(runtime_error);
    }
    if(child == 0) {
        if(dup2(pipes[0], 0) < 0) {
            perror("dup2ing input to child's stdin");
            exit(runtime_error);
        }
        close(pipes[0]);
        close(pipes[1]);
        printf("child: executing...\n");
        execl("/bin/sh", "/bin/sh", "-s", NULL);
        perror("executing /bin/sh for test");
        exit(runtime_error);
    }

    close(pipes[0]);
    tochild = fdopen(pipes[1], "w");
    if(!tochild) {
        perror("calling fdopen on pipe");
        exit(runtime_error);
    }

    printf("parent: printing...\n");
    print_template(&test, exec_template, tochild);
    fclose(tochild);

    status = wait_for_child(child);
    printf("STATUS was %d\n", status);

    // if shell returned an error, then we need to know if this
    // error was during the config phase or the test run phase.
    // TODO: how do we tell the difference between a config file
    // error and a real error?


    // what do we want to do?
    //     regular running test?  compare actual stdout and stderr to expected.
    //        (rewind outfiles, compare as we parse the testfile)
    //     we have a routine that will generate a new test file based on the old.
    //       output: it just dumps that new test file to stdout.
    //       diff: it pipes that new file to a forked diff process
    //          need to cd to orig dir before running diff so it has
    //          the correct path to the file.  otherwise patch won't run.

    // printf("ok   %s\n", name);
}


/** This routine filters out any dirents that begin with '.'.
 *  We don't want to process any hidden files or special directories.
 */

int select_nodots(const struct dirent *d)
{
    return d->d_name[0] != '.';
}


// forward declaration for recursion
void process_dir();


/** Process all entries in a directory.
 *
 * See run_test() for an explanation of warn_suffix.
 */

void process_ents(char **ents, int warn_suffix)
{
    static char pathbuf[PATH_MAX];
    struct stat st;
    mode_t *modes;
    int i, n;
    char *slash;

    for(n=0; ents[n]; n++)
        ;

    modes = malloc(n * sizeof(mode_t));
    if(!modes) {
        fprintf(stderr, "Could not allocate %d mode_t objects.\n", n);
        exit(runtime_error);
    }
    
    // first collect the stat info for each entry
    for(i=0; i<n; i++) {
        if(stat(ents[i], &st) < 0) {
            fprintf(stderr, "stat error on '%s': %s\n", ents[i], strerror(errno));
            exit(runtime_error);
        }
        modes[i] = st.st_mode;
    }

    // process all files in dir
    for(i=0; i<n; i++) {
        if(S_ISREG(modes[i])) {
            run_test(ents[i], warn_suffix);
            modes[i] = 0;
        }
    }

    // process all subdirs
    for(i=0; i<n; i++) {
        if(modes[i] == 0) continue;
        if(S_ISDIR(modes[i])) {
            chdir(ents[i]);
            if(pathbuf[0]) strncat(pathbuf, "/", sizeof(pathbuf));
            strncat(pathbuf, ents[i], sizeof(pathbuf));
            printf("\nProcessing %s\n", pathbuf);
            process_dir();
            slash = strrchr(pathbuf, '/');
            if(slash) {
                *slash = '\0';
            } else {
                pathbuf[0] = '\0';
            }
            chdir("..");
        }
    }

    free(modes);
}


/** Runs all tests in the current directory and all its subdirectories.
 */

void process_dir()
{
    char **ents;
    int i;

    ents = qscandir(".", select_nodots, qdirentcoll);
    if(!ents) {
        // qscandir has already printed the error message
        exit(runtime_error);
    }

    process_ents(ents, 0);

    for(i=0; ents[i]; i++) {
        free(ents[i]);
    }
    free(ents);
}


int open_file(const char *fn)
{
    int fd = open(fn, O_RDWR|O_CREAT/*|O_EXCL*/, S_IRUSR|S_IWUSR);

    if(fd < 0) {
        fprintf(stderr, "couldn't open %s: %s\n", fn, strerror(errno));
        exit(runtime_error);
    }

    return fd;
}


/** Prepare system for running tests.
 *
 * We do all I/O for all tests through only three file descriptors.
 * We seek to the beginning of each file before running each test.
 * This should save some inode thrashing.
 */

void start_tests()
{
    g_outfd = open_file("/tmp/tmtest-outfile");
    g_errfd = open_file("/tmp/tmtest-errfile");
}


void stop_tests()
{
    close(g_outfd);
    close(g_errfd);
}


void usage()
{
	printf(
			"Usage: tmtest [OPTION]... [DLDIR]\n"
			"  -o: output the test file with the new output.\n"
			"  -d: output a diff between the expected and actual outputs.\n"
            "  -D NAME=VAL: define a variable on the command line.\n"
            "  -t --timeout: time in seconds before test is terminated.\n"
			"  -v --verbose: increase verbosity.\n"
			"  -V --version: print the version of this program.\n"
			"  -h --help: prints this help text\n"
			"Run tmtest with no arguments to run all tests in the current directory.\n"
		  );
}


void process_args(int argc, char **argv)
{
    char buf[256], *cp;
    int optidx, i, c;

	while(1) {
		optidx = 0;
		static struct option longopts[] = {
			// name, has_arg (1=reqd,2=opt), flag, val
			{"diff", 0, 0, 'd'},
			{"define", 1, 0, 'D'},
			{"help", 0, 0, 'h'},
			{"output", 0, 0, 'o'},
			{"timeout", 1, 0, 't'},
			{"verbose", 0, 0, 'v'},
			{"version", 0, 0, 'V'},
			{0, 0, 0, 0},
		};

        // dynamically create the option string from the long
        // options.  Why oh why doesn't glibc do this for us???
        cp = buf;
        for(i=0; longopts[i].name; i++) {
            *cp++ = longopts[i].val;
            if(longopts[i].has_arg > 0) *cp++ = ':';
            if(longopts[i].has_arg > 1) *cp++ = ':';
        }
        *cp++ = '\0';

		c = getopt_long(argc, argv, buf, longopts, &optidx);
		if(c == -1) break;

		switch(c) {
            case 'd':
                outmode = outmode_diff;
                break;

			case 'D':
                add_define(optarg);
				break;

			case 'h':
				usage();
				exit(0);

			case 'o':
                outmode = outmode_output;
				break;

			case 't':
				sscanf(optarg, "%lf", &timeout);
				break;

			case 'v':
				verbose++;
				break;

			case 'V':
				printf("tmtest version %s\n", stringify(VERSION));
				exit(0);

                /*
			case 0:
			case '?':
				break;
                */

			default:
				exit(argument_error);

		}
	}

	if(verbose) {
        switch(outmode) {
            case outmode_normal:
                printf("Running tests.\n");
                break;
            case outmode_output:
                printf("Outputting tests.\n");
                break;
            case outmode_diff:
                printf("Diffing tests.\n");
                break;
            default:
                assert(0);
        }
		printf("Timeout is %lf seconds\n", timeout);
	}
}


int main(int argc, char **argv)
{
	process_args(argc, argv);

    start_tests();
    if(optind < argc) {
        process_ents(argv+1, 1);
    } else {
        process_dir();
    }
    stop_tests();

	return 0;
}

