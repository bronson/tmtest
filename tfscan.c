/* Generated by re2c 0.5 on Sun Dec 18 12:25:00 2005 */

/* tfscan.re
 * Scott Bronson
 * 30 Dec 2004
 *
 * Scanner for test files.
 * This file needs to be processed by re2c, http://re2c.org
 *
 * This file is covered by the MIT License.
 */

#include "tfscan.h"


#define START(x) (ss->scanref=(void*)(x))


/* This scanner scans lines.  When it finds a line that begins
 * with a new section, it returns the token name of that section
 * with the exNEW flag turned on.  After that, it returns each
 * line in the section with the token's identifier.  Then, when it
 * finds a new section, you get a exNEW+TOKEN of the new section.
 */

int tfscan_start(scanstate *ss)
{
    scanner_enter(ss);
    inc_line(ss);

{
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy0;
yy1:	++YYCURSOR;
yy0:
	if((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
	yych = *YYCURSOR;
	switch(yych){
	case '\n':	goto yy7;
	case 'M':	goto yy4;
	case 'R':	goto yy3;
	case 'S':	goto yy2;
	default:	goto yy5;
	}
yy2:	yych = *++YYCURSOR;
	switch(yych){
	case 'T':	goto yy29;
	default:	goto yy6;
	}
yy3:	yych = *++YYCURSOR;
	switch(yych){
	case 'E':	goto yy19;
	default:	goto yy6;
	}
yy4:	yych = *++YYCURSOR;
	switch(yych){
	case 'O':	goto yy9;
	default:	goto yy6;
	}
yy5:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy6;
yy6:	switch(yych){
	case '\n':	goto yy7;
	default:	goto yy5;
	}
yy7:	yych = *++YYCURSOR;
	goto yy8;
yy8:

	{ return (int)ss->scanref; }
yy9:	yych = *++YYCURSOR;
	switch(yych){
	case 'D':	goto yy10;
	default:	goto yy6;
	}
yy10:	yych = *++YYCURSOR;
	switch(yych){
	case 'I':	goto yy11;
	default:	goto yy6;
	}
yy11:	yych = *++YYCURSOR;
	switch(yych){
	case 'F':	goto yy12;
	default:	goto yy6;
	}
yy12:	yych = *++YYCURSOR;
	switch(yych){
	case 'Y':	goto yy13;
	default:	goto yy6;
	}
yy13:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy14;
yy14:	switch(yych){
	case '\t':	case ' ':	goto yy13;
	case '\n':	goto yy7;
	case ':':	goto yy15;
	default:	goto yy5;
	}
yy15:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy16;
yy16:	switch(yych){
	case '\n':	goto yy17;
	default:	goto yy15;
	}
yy17:	yych = *++YYCURSOR;
	goto yy18;
yy18:

	{ START(exMODIFY); return exNEW|exMODIFY; }
yy19:	yych = *++YYCURSOR;
	switch(yych){
	case 'S':	goto yy20;
	default:	goto yy6;
	}
yy20:	yych = *++YYCURSOR;
	switch(yych){
	case 'U':	goto yy21;
	default:	goto yy6;
	}
yy21:	yych = *++YYCURSOR;
	switch(yych){
	case 'L':	goto yy22;
	default:	goto yy6;
	}
yy22:	yych = *++YYCURSOR;
	switch(yych){
	case 'T':	goto yy23;
	default:	goto yy6;
	}
yy23:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy24;
yy24:	switch(yych){
	case '\t':	case ' ':	goto yy23;
	case '\n':	goto yy7;
	case ':':	goto yy25;
	default:	goto yy5;
	}
yy25:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy26;
yy26:	switch(yych){
	case '\n':	goto yy27;
	default:	goto yy25;
	}
yy27:	yych = *++YYCURSOR;
	goto yy28;
yy28:

	{ START(exRESULT); return exNEW|exRESULT; }
yy29:	yych = *++YYCURSOR;
	switch(yych){
	case 'D':	goto yy30;
	default:	goto yy6;
	}
yy30:	yych = *++YYCURSOR;
	switch(yych){
	case 'E':	goto yy31;
	case 'O':	goto yy32;
	default:	goto yy6;
	}
yy31:	yych = *++YYCURSOR;
	switch(yych){
	case 'R':	goto yy40;
	default:	goto yy6;
	}
yy32:	yych = *++YYCURSOR;
	switch(yych){
	case 'U':	goto yy33;
	default:	goto yy6;
	}
yy33:	yych = *++YYCURSOR;
	switch(yych){
	case 'T':	goto yy34;
	default:	goto yy6;
	}
yy34:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy35;
yy35:	switch(yych){
	case '\t':	case ' ':	goto yy34;
	case '\n':	goto yy7;
	case ':':	goto yy36;
	default:	goto yy5;
	}
yy36:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy37;
yy37:	switch(yych){
	case '\n':	goto yy38;
	default:	goto yy36;
	}
yy38:	yych = *++YYCURSOR;
	goto yy39;
yy39:

	{ START(exSTDOUT); return exNEW|exSTDOUT; }
yy40:	yych = *++YYCURSOR;
	switch(yych){
	case 'R':	goto yy41;
	default:	goto yy6;
	}
yy41:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy42;
yy42:	switch(yych){
	case '\t':	case ' ':	goto yy41;
	case '\n':	goto yy7;
	case ':':	goto yy43;
	default:	goto yy5;
	}
yy43:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy44;
yy44:	switch(yych){
	case '\n':	goto yy45;
	default:	goto yy43;
	}
yy45:	yych = *++YYCURSOR;
	goto yy46;
yy46:

	{ START(exSTDERR); return exNEW|exSTDERR; }
}


}


/** Prepares the given scanner to scan a testfile.
 *
 *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
 *  @returns ss.  Always.  This routine makes no calls that can fail.
 */

scanstate* tfscan_attach(scanstate *ss)
{
    if(ss) {
        START(exCOMMAND);
        ss->state = tfscan_start;
    }

    return ss;
}

