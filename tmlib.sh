# tmlib.sh

# Utilities useful for writing tmtest testfiles and other shell scripts.
# To use them, just include this file: . "$HOME/.tmlib.sh"
# This file is covered by the MIT License.

# DO NOT EDIT THIS FILE!  Edit /etc/tmtest.conf or ~/.tmtestrc instead.
# This file is replaced when you reinstall tmtest and your changes
# will be lost!


# tmlib functions:
#
# TRAP:     Execute a command when an exception happens
# ATEXIT:   Ensure a command runs even if the test fails (usually to clean up).
# REPLACE:  replaces literal text with other literal text (no regexes).


#
# TRAP
#
# This function makes trap behave more like atexit(3), where you can
# install multiple commands to execute for the same condition.
# I'm surprised that Bash doesn't do this by default.
#
# NOTE: you must not mix use of TRAP and trap on the same conndition.
# The builtin trap will remove TRAP's condition, and all the commands
# installed using TRAP will not be run.
#
# Call this routine exactly like the trap builtin: "TRAP cmd cond"
#
# Example:
#
#     TRAP "echo debug!" DEBUG
#

TRAP ()
{
	# install the trap if this is the first time TRAP is called for
	# the given condition.  (Is there any way to get rid of "local var"??)

	local var=TRAP_$2
	if [ ! -n "${!var}" ]; then
		trap "eval \"\$TRAP_$2\"" $2
	fi


	# This just adds $1 to the front of the string given by TRAP_$2.
	# In Perl:		$TRAP{$2} = $1.($TRAP{$2} ? "; " : "").$TRAP{$2}

	eval TRAP_$2=\"$1'${'TRAP_$2':+; }$'TRAP_$2\"
}


#
# ATEXIT
#
# This behaves just like atexit(3) call.  Supply a command to be executed
# when the shell exits.  Commands are executed in the reverse order that
# they are supplied.
#
# Example:  (will produce "BA" on stdout when the test ends)
#
#     ATEXIT "echo A"
#     ATEXIT "echo -n B"

ATEXIT ()
{
	TRAP "$*" EXIT
}


#
# REPLACE
#
# Replaces all occurrences of the first argument with the second argument.
# Takes any number of arguments:
#   echo "'a'" | REPLACE "'a'" "/\\a/\\"
# replaces all occurrences of 'a' with /\a/\
#   REPLACE abc ABC def DEF ghi GHI
# converts the first nine characters of the alphabet to upper case
# All non-control characters are safe: quotes, slashes, etc.
# You can of course use sed if you want to replace with regexes.
# Replace does not work if a newline is embedded in either argument.
#
# Three layers of escaping!  (bash, perlvar, perlre)  This is insane.
# I wish sed or awk would work with raw strings instead of regexes.
# Why isn't a replace utility a part of Gnu coreutils?
#

REPLACE()
{
    # unfortunately bash can't handle this substitution itself because it
    # must work on ' and \ simultaneously. Send it to perl for processing.

     ( while [ "$1" != "" ]; do echo "$1"; shift; done; echo; cat) | perl -e "my %ops; while(<>) { chomp; last if \$_ eq ''; \$_ = quotemeta(\$_); \$ops{\$_} = <>; chomp(\$ops{\$_}); warn 'odd number of arguments to REPLACE', last if \$ops{\$_} eq ''; } while(<>) { for my \$k (keys %ops) { s/\$k/\$ops{\$k}/g } print or die \"REPLACE: Could not print: \$!\\\\n\"; }"
}
