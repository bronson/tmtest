/* Generated by re2c 0.13.5 on Mon Feb 21 20:40:42 2011 */

/* stscan.re
 * Scott Bronson
 *
 * This file is covered by the MIT license.
 *
 * Scanner for status files files.
 * This file needs to be processed by re2c, http://re2c.org
 */

#include "stscan.h"


/* This scanner scans lines.  When it finds a line that begins
 * with a recognized token, it returns that token with the text
 * of the entire line.  Otherwise, it returns stGARBAGE.
 *
 * Note that this scanner only returns complete lines.  If the file
 * doesn't end with a newline, then the last line will be lost.
 * I think.
 */

int stscan_start(scanstate *ss)
{
    scanner_enter(ss);
    scan_inc_line(ss);



{
	YYCTYPE yych;

	if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy10;
	case 'A':	goto yy7;
	case 'C':	goto yy3;
	case 'D':	goto yy6;
	case 'P':	goto yy4;
	case 'R':	goto yy5;
	case 'S':	goto yy2;
	default:	goto yy8;
	}
yy2:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'T':	goto yy78;
	default:	goto yy9;
	}
yy3:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'O':	goto yy68;
	default:	goto yy9;
	}
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'R':	goto yy56;
	default:	goto yy9;
	}
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'U':	goto yy44;
	default:	goto yy9;
	}
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'I':	goto yy23;
	case 'O':	goto yy24;
	default:	goto yy9;
	}
yy7:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'B':	goto yy12;
	default:	goto yy9;
	}
yy8:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy9:
	switch (yych) {
	case '\n':	goto yy10;
	default:	goto yy8;
	}
yy10:
	++YYCURSOR;

	{ return stGARBAGE; }

yy12:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'O':	goto yy13;
	default:	goto yy9;
	}
yy13:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'R':	goto yy14;
	default:	goto yy9;
	}
yy14:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'T':	goto yy15;
	default:	goto yy9;
	}
yy15:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':	goto yy16;
	default:	goto yy9;
	}
yy16:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'D':	goto yy17;
	default:	goto yy9;
	}
yy17:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy17;
	case '\n':	goto yy10;
	case ':':	goto yy19;
	default:	goto yy8;
	}
yy19:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy21;
	default:	goto yy19;
	}
yy21:
	++YYCURSOR;

	{ return stABORTED; }

yy23:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'S':	goto yy33;
	default:	goto yy9;
	}
yy24:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'N':	goto yy25;
	default:	goto yy9;
	}
yy25:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':	goto yy26;
	default:	goto yy9;
	}
yy26:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy29;
	case '\n':	goto yy27;
	default:	goto yy8;
	}
yy27:
	++YYCURSOR;

	{ return stDONE; }

yy29:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy29;
	case '\n':	goto yy27;
	default:	goto yy31;
	}
yy31:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy27;
	default:	goto yy31;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'A':	goto yy34;
	default:	goto yy9;
	}
yy34:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'B':	goto yy35;
	default:	goto yy9;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':	goto yy36;
	default:	goto yy9;
	}
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':	goto yy37;
	default:	goto yy9;
	}
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'D':	goto yy38;
	default:	goto yy9;
	}
yy38:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy38;
	case '\n':	goto yy10;
	case ':':	goto yy40;
	default:	goto yy8;
	}
yy40:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy42;
	default:	goto yy40;
	}
yy42:
	++YYCURSOR;

	{ return stDISABLED; }

yy44:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'N':	goto yy45;
	default:	goto yy9;
	}
yy45:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'N':	goto yy46;
	default:	goto yy9;
	}
yy46:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'I':	goto yy47;
	default:	goto yy9;
	}
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'N':	goto yy48;
	default:	goto yy9;
	}
yy48:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'G':	goto yy49;
	default:	goto yy9;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy52;
	case '\n':	goto yy50;
	default:	goto yy8;
	}
yy50:
	++YYCURSOR;

	{ return stRUNNING; }

yy52:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy52;
	case '\n':	goto yy50;
	default:	goto yy54;
	}
yy54:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy50;
	default:	goto yy54;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':	goto yy57;
	default:	goto yy9;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'P':	goto yy58;
	default:	goto yy9;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'A':	goto yy59;
	default:	goto yy9;
	}
yy59:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'R':	goto yy60;
	default:	goto yy9;
	}
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':	goto yy61;
	default:	goto yy9;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy64;
	case '\n':	goto yy62;
	default:	goto yy8;
	}
yy62:
	++YYCURSOR;

	{ return stPREPARE; }

yy64:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy64;
	case '\n':	goto yy62;
	default:	goto yy66;
	}
yy66:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy62;
	default:	goto yy66;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'N':	goto yy69;
	default:	goto yy9;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'F':	goto yy70;
	default:	goto yy9;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'I':	goto yy71;
	default:	goto yy9;
	}
yy71:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'G':	goto yy72;
	default:	goto yy9;
	}
yy72:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy72;
	case '\n':	goto yy10;
	case ':':	goto yy74;
	default:	goto yy8;
	}
yy74:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy76;
	default:	goto yy74;
	}
yy76:
	++YYCURSOR;

	{ return stCONFIG; }

yy78:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'A':	goto yy79;
	default:	goto yy9;
	}
yy79:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'R':	goto yy80;
	default:	goto yy9;
	}
yy80:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'T':	goto yy81;
	default:	goto yy9;
	}
yy81:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy84;
	case '\n':	goto yy82;
	default:	goto yy8;
	}
yy82:
	++YYCURSOR;

	{ return stSTART; }

yy84:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy84;
	case '\n':	goto yy82;
	default:	goto yy86;
	}
yy86:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy82;
	default:	goto yy86;
	}
}


}


/** Prepares the given scanner to scan a status file.
 *
 *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
 *  @returns ss.  Always.  This routine makes no calls that can fail.
 */

scanstate* stscan_attach(scanstate *ss)
{
    if(ss) {
        ss->state = stscan_start;
    }

    return ss;
}

